diff --git a/src/modules/email_ingestion.py b/src/modules/email_ingestion.py
index fcd44c1..b4eaad6 100644
--- a/src/modules/email_ingestion.py
+++ b/src/modules/email_ingestion.py
@@ -17,6 +17,7 @@ from email.header import decode_header, make_header
 from email.utils import getaddresses

 from ..utils.config import EmailAccountConfig
+from ..utils.sanitization import sanitize_for_logging


 @dataclass
@@ -203,13 +204,16 @@ class IMAPClient:
         try:
             status, data = self.connection.select(folder)
             if status == "OK":
-                self.logger.debug(f"Selected folder: {folder}")
+                safe_folder = sanitize_for_logging(folder)
+                self.logger.debug(f"Selected folder: {safe_folder}")
                 return True
             else:
-                self.logger.warning(f"Could not select folder {folder}: {status}")
+                safe_folder = sanitize_for_logging(folder)
+                self.logger.warning(f"Could not select folder {safe_folder}: {status}")
                 return False
         except Exception as e:
-            self.logger.error(f"Error selecting folder {folder}: {e}")
+            safe_folder = sanitize_for_logging(folder)
+            self.logger.error(f"Error selecting folder {safe_folder}: {e}")
             return False

     def fetch_unseen_emails(self, folder: str, limit: int = 50) -> List[Tuple[str, bytes]]:
@@ -230,20 +234,22 @@ class IMAPClient:
             # Search for unseen messages
             status, messages = self.connection.search(None, "UNSEEN")

+            safe_folder = sanitize_for_logging(folder)
+
             if status != "OK":
-                self.logger.warning(f"Search failed in {folder}")
+                self.logger.warning(f"Search failed in {safe_folder}")
                 return []

             email_ids = messages[0].split()

             if not email_ids:
-                self.logger.debug(f"No unseen emails in {folder}")
+                self.logger.debug(f"No unseen emails in {safe_folder}")
                 return []

             # Limit number of emails to fetch
             email_ids = email_ids[:limit]

-            self.logger.info(f"Found {len(email_ids)} unseen emails in {folder}")
+            self.logger.info(f"Found {len(email_ids)} unseen emails in {safe_folder}")

             emails = []
             batch_size = 10  # Process in small batches to respect rate limits while improving speed
@@ -323,6 +329,8 @@ class IMAPClient:
             attachments = []
             current_total_size = 0

+            safe_email_id = sanitize_for_logging(email_id)
+
             if msg.is_multipart():
                 for part in msg.walk():
                     content_type = part.get_content_type()
@@ -335,7 +343,7 @@ class IMAPClient:
                             body_text += text_part
                             if len(body_text) > self.max_body_size:
                                 body_text = body_text[:self.max_body_size]
-                                self.logger.warning(f"Body text truncated to {self.max_body_size} bytes for email {email_id}")
+                                self.logger.warning(f"Body text truncated to {self.max_body_size} bytes for email {safe_email_id}")

                     # Extract HTML body
                     elif content_type == "text/html" and "attachment" not in content_disposition:
@@ -344,14 +352,14 @@ class IMAPClient:
                             body_html += html_part
                             if len(body_html) > self.max_body_size:
                                 body_html = body_html[:self.max_body_size]
-                                self.logger.warning(f"Body HTML truncated to {self.max_body_size} bytes for email {email_id}")
+                                self.logger.warning(f"Body HTML truncated to {self.max_body_size} bytes for email {safe_email_id}")

                     # Extract attachments
                     elif "attachment" in content_disposition:
                         # Check attachment count limit
                         if len(attachments) >= self.max_attachment_count:
                             self.logger.warning(
-                                f"Max attachment count ({self.max_attachment_count}) reached for email {email_id}. Skipping remaining attachments."
+                                f"Max attachment count ({self.max_attachment_count}) reached for email {safe_email_id}. Skipping remaining attachments."
                             )
                             continue

@@ -360,10 +368,12 @@ class IMAPClient:
                             payload = part.get_payload(decode=True) or b""
                             original_size = len(payload)

+                            safe_filename = sanitize_for_logging(filename)
+
                             # Check total size limit before adding
                             if self.max_total_attachment_bytes > 0 and (current_total_size + original_size) > self.max_total_attachment_bytes:
                                 self.logger.warning(
-                                    f"Max total attachment size ({self.max_total_attachment_bytes}) exceeded for email {email_id}. Skipping attachment {filename}."
+                                    f"Max total attachment size ({self.max_total_attachment_bytes}) exceeded for email {safe_email_id}. Skipping attachment {safe_filename}."
                                 )
                                 continue

@@ -371,7 +381,7 @@ class IMAPClient:
                             if self.max_attachment_bytes > 0 and original_size > self.max_attachment_bytes:
                                 self.logger.warning(
                                     "Attachment %s exceeds max size (%d bytes); truncating for analysis",
-                                    filename,
+                                    safe_filename,
                                     original_size,
                                 )
                                 payload = payload[:self.max_attachment_bytes]
@@ -395,12 +405,12 @@ class IMAPClient:
                         if content_type == "text/html":
                             if len(decoded) > self.max_body_size:
                                 decoded = decoded[:self.max_body_size]
-                                self.logger.warning(f"Body HTML truncated to {self.max_body_size} bytes for email {email_id}")
+                                self.logger.warning(f"Body HTML truncated to {self.max_body_size} bytes for email {safe_email_id}")
                             body_html = decoded
                         else:
                             if len(decoded) > self.max_body_size:
                                 decoded = decoded[:self.max_body_size]
-                                self.logger.warning(f"Body text truncated to {self.max_body_size} bytes for email {email_id}")
+                                self.logger.warning(f"Body text truncated to {self.max_body_size} bytes for email {safe_email_id}")
                             body_text = decoded
                 except Exception:
                     pass
@@ -428,7 +438,8 @@ class IMAPClient:
             )

         except Exception as e:
-            self.logger.error(f"Error parsing email {email_id}: {e}")
+            safe_email_id = sanitize_for_logging(email_id)
+            self.logger.error(f"Error parsing email {safe_email_id}: {e}")
             return None

     def diagnose_connection_issues(self, account: EmailAccountConfig) -> Dict[str, Any]:
diff --git a/tests/test_dos_prevention.py b/tests/test_dos_prevention.py
index 452e021..7940c82 100644
--- a/tests/test_dos_prevention.py
+++ b/tests/test_dos_prevention.py
@@ -15,7 +15,8 @@ class TestDoSPrevention(unittest.TestCase):
             app_password="pass",
             folders=["INBOX"],
             provider="test",
-            use_ssl=True
+            use_ssl=True,
+            verify_ssl=True
         )
         self.client = IMAPClient(self.account_config)
         # Set limit to 1KB for testing
